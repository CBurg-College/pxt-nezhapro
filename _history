{"entries":[{"timestamp":1757003257603,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":5165,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":118,"length1":140,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":235,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1757003857187,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":476,"length1":33,"diffs":[[1,"    function __move(motor: MotorPostion, direction: MovementDirection, value: number, mode: SportsMode): void {\r\n"]]},{"start1":591,"length1":632,"diffs":[[1,""]]},{"start1":904,"length1":7,"diffs":[[1,""]]},{"start1":906,"length1":3131,"diffs":[[1,""]]}]}]},{"timestamp":1757004409474,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":509,"length1":76,"diffs":[[1,""]]},{"start1":1035,"length1":720,"diffs":[[1,""]]}]}]},{"timestamp":1757004578915,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5416,"length1":0,"diffs":[[1,"\r\n    // MOTOR MODULE\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n"]]}]}]},{"timestamp":1757005364306,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5392,"length1":1008,"diffs":[[1,""]]}]}]},{"timestamp":1757005375010,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":587,"length1":174,"diffs":[[1,"    export enum MotorPostion {\r\n        //%block=\"M1\"\r\n        M1 = 1,\r\n        //%block=\"M2\"\r\n        M2 = 2,\r\n        //%block=\"M3\"\r\n        M3 = 3,\r\n        //%block=\"M4\"\r\n        M4 = 4\r\n    }\r\n"]]},{"start1":787,"length1":0,"diffs":[[1,"    export enum MovementDirection {\r\n        //%block=\"clockwise\"\r\n        CW = 1,\r\n        //%block=\"counterclockwise\"\r\n        CCW = 2\r\n    }\r\n\r\n"]]},{"start1":958,"length1":47,"diffs":[[1,""]]},{"start1":1007,"length1":0,"diffs":[[1,"        //%block=\"turns\"\r\n        Circle = 1,\r\n"]]},{"start1":1831,"length1":85,"diffs":[[1,"    function _move(motor: MotorPostion, direction: MovementDirection, value: number, mode: Mode): void {\r\n"]]},{"start1":2028,"length1":136,"diffs":[[1,"        buf[2] = motor;\r\n        buf[3] = direction;\r\n"]]},{"start1":2261,"length1":49,"diffs":[[1,"    export function _stop(motor: MotorPostion): void {\r\n"]]},{"start1":2405,"length1":29,"diffs":[[1,"        buf[2] = motor;\r\n"]]},{"start1":2603,"length1":81,"diffs":[[1,"    export function _start(motor: MotorPostion, direction: MovementDirection, speed: number): void {\r\n"]]},{"start1":2793,"length1":61,"diffs":[[1,"        buf[2] = motor;\r\n        buf[3] = direction;\r\n"]]},{"start1":3009,"length1":52,"diffs":[[1,"    export function _angle(motor: MotorPostion): number {\r\n"]]},{"start1":3177,"length1":29,"diffs":[[1,"        buf[2] = motor;\r\n"]]},{"start1":3522,"length1":52,"diffs":[[1,"    export function _speed(motor: MotorPostion): number {\r\n"]]},{"start1":3689,"length1":29,"diffs":[[1,"        buf[2] = motor;\r\n"]]},{"start1":4057,"length1":50,"diffs":[[1,"    export function _reset(motor: MotorPostion): void {\r\n"]]},{"start1":4202,"length1":29,"diffs":[[1,"        buf[2] = motor;\r\n"]]},{"start1":4480,"length1":56,"diffs":[[1,"    export function setServoSpeed(speed: number): void {\r\n"]]},{"start1":5417,"length1":856,"diffs":[[1,""]]},{"start1":6400,"length1":0,"diffs":[[1,"}\r\n\r\nnamespace Nezha {\r\n"]]}]}]},{"timestamp":1757005968485,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1836,"length1":52,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1 instead of 0, etc.\r\n"]]},{"start1":2659,"length1":130,"diffs":[[1,"        buf[2] = motor + 1;\r\n        buf[3] = rotation + 1;\r\n"]]},{"start1":3043,"length1":52,"diffs":[[1,"        buf[2] = motor + 1;\r\n"]]},{"start1":3552,"length1":52,"diffs":[[1,"        buf[2] = motor + 1;\r\n"]]},{"start1":3924,"length1":59,"diffs":[[1,"    export function _reset(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x1D;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        relativeAngularArr[motor - 1] = 0;\r\n        motorDelay(1, Mode.Second)\r\n    }\r\n\r\n    export function _servoSpeed(speed: number): void {\r\n"]]},{"start1":4797,"length1":7,"diffs":[[1,""]]},{"start1":4799,"length1":434,"diffs":[[1,""]]},{"start1":6086,"length1":869,"diffs":[[1,""]]}]}]},{"timestamp":1757006384925,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6307,"length1":81,"diffs":[[1,""]]}]}]},{"timestamp":1757006765217,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7169,"length1":954,"diffs":[[1,""]]}]}]},{"timestamp":1757009901399,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7427,"length1":0,"diffs":[[1,"        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n"]]}]}]},{"timestamp":1757009915043,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":940,"length1":89,"diffs":[[1,""]]},{"start1":1034,"length1":49,"diffs":[[1,"        while (time >= input.runningTime()) {\r\n\r\n        }\r\n"]]},{"start1":1649,"length1":0,"diffs":[[1,"\r\n"]]},{"start1":1836,"length1":61,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = rotation + 1; // Spin.Clockwise = 1, Spin.AntiClockwise = 2\r\n"]]},{"start1":2145,"length1":625,"diffs":[[1,""]]},{"start1":2653,"length1":61,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = rotation + 1; // Spin.Clockwise = 1, Spin.AntiClockwise = 2\r\n"]]},{"start1":3106,"length1":29,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n"]]},{"start1":3638,"length1":29,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n"]]},{"start1":4636,"length1":29,"diffs":[[1,"        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n"]]},{"start1":7505,"length1":0,"diffs":[[1,"        if (Servos[servo] != ServoType.ST180) return\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = speed;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n"]]}]}]},{"timestamp":1757010485426,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2681,"length1":42,"diffs":[[1,"        delayMs(4);\r\n"]]},{"start1":2775,"length1":0,"diffs":[[1,"\r\n"]]},{"start1":4018,"length1":464,"diffs":[[1,""]]}]}]},{"timestamp":1757011083820,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":541,"length1":37,"diffs":[[1,"    let relativeAngularArr = [0, 0, 0, 0];\r\n"]]},{"start1":2152,"length1":135,"diffs":[[1,"    export function _moveToAngle(motor: Motor, rotation: Spin, angle: number, isDelay: DelayMode = DelayMode.AutoDelayStatus): void {\r\n"]]},{"start1":3135,"length1":87,"diffs":[[1,"    export function _start(motor: Motor, rotation: Spin, speed: number): void {\r\n"]]},{"start1":3527,"length1":56,"diffs":[[1,"    export function _angle(motor: Motor): number {\r\n"]]},{"start1":3599,"length1":536,"diffs":[[1,""]]},{"start1":4092,"length1":42,"diffs":[[1,"        let position = _angle(motor)\r\n"]]},{"start1":4254,"length1":106,"diffs":[[1,"    export function _RelAngle(motor: Motor) {\r\n        relativeAngularArr[motor - 1] = _angle(motor);\r\n"]]},{"start1":4421,"length1":64,"diffs":[[1,"        return (_angle(motor) - relativeAngularArr[motor - 1]) * 0.1;\r\n"]]},{"start1":4501,"length1":0,"diffs":[[1,"    export function _speed(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x47;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 2);\r\n        let retData = (arr[1] << 8) | (arr[0]);\r\n        return Math.floor(retData / 3.6) * 0.01;\r\n    }\r\n\r\n"]]},{"start1":5829,"length1":37,"diffs":[[1,"        relativeAngularArr[motor - 1] = 0;\r\n"]]},{"start1":7284,"length1":87,"diffs":[[1,"        _start( motor, speed >= 0 ? Spin.Clockwise : Spin.AntiClockwise, speed)\r\n"]]}]}]},{"timestamp":1757011410741,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2280,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1757013029072,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1244,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1757013033620,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":780,"length1":75,"diffs":[[1,"        //%block=\"turns\"\r\n"]]},{"start1":827,"length1":64,"diffs":[[1,"        //%block=\"degrees\"\r\n"]]},{"start1":876,"length1":66,"diffs":[[1,"        //%block=\"seconds\"\r\n"]]},{"start1":1071,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1757014011565,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3257,"length1":81,"diffs":[[1,"    export function _turnAtSpeed(motor: Motor, rotation: Spin, speed: number): void {\r\n"]]}]}]},{"timestamp":1757014070856,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2918,"length1":81,"diffs":[[1,"    export function _stop(motor: Motor): void {\r\n"]]},{"start1":3084,"length1":93,"diffs":[[1,"        buf[3] = 0x00;\r\n        buf[4] = 0x5F;\r\n        buf[5] = 0x00;\r\n"]]},{"start1":3257,"length1":49,"diffs":[[1,"    export function _start(motor: Motor, rotation: Spin, speed: number): void {\r\n"]]},{"start1":3455,"length1":72,"diffs":[[1,"        buf[3] = rotation + 1;\r\n        buf[4] = 0x60;\r\n        buf[5] = Math.floor(speed);\r\n"]]},{"start1":7407,"length1":81,"diffs":[[1,"        _turnAtSpeed( motor, speed >= 0 ? Spin.Clockwise : Spin.AntiClockwise, speed)\r\n"]]},{"start1":8533,"length1":99,"diffs":[[1,""]]},{"start1":8620,"length1":0,"diffs":[[1,"}\r\n"]]},{"start1":8625,"length1":0,"diffs":[[1,"namespace Nezha {\r\n\r\n    // MOTOR MODULE\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        speed = Math.map(speed, 0, 100, 0, 150)\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 150) speed = 150\r\n        else\r\n            if (speed < -150) speed = -150\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n        if (Servos[servo] != ServoType.ST180) return\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = speed;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n"]]},{"start1":12877,"length1":240,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1757014651132,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":8292,"length1":75,"diffs":[[1,"    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n"]]},{"start1":8356,"length1":121,"diffs":[[1,"    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n"]]},{"start1":8527,"length1":50,"diffs":[[1,"        angle = Math.map(speed, 0, 100, 0, 150)\r\n        pins.servoWritePin(AnalogPin.P15, angle)\r\n"]]},{"start1":8635,"length1":0,"diffs":[[1,"    export function servoSpeed(servo: Servo, speed: number): void {\r\n    }\r\n\r\n\r\n"]]}]}]},{"timestamp":1757015205165,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":8269,"length1":217,"diffs":[[1,""]]},{"start1":8499,"length1":25,"diffs":[[1,""]]},{"start1":9485,"length1":0,"diffs":[[1,"\r\npins.servoSetPulse(AnalogPin.P15, 1500)\r\nbasic.forever(function () {\r\n    basic.showArrow(ArrowNames.North)\r\n    basic.pause(2000)\r\n    pins.servoWritePin(AnalogPin.P15, 0)\r\n    basic.showArrow(ArrowNames.South)\r\n    basic.pause(2000)\r\n})\r\n"]]}]}]},{"timestamp":1757015936350,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":8486,"length1":150,"diffs":[[1,""]]}]}]},{"timestamp":1757015941332,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":8511,"length1":92,"diffs":[[1,"    export function getServoAngle(servo: Servo): number {\r\n        return pins.servoWritePin(Servos[servo], angle)\r\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":349,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests gaan hier; deze zal niet worden gecompileerd wanneer dit pakket wordt gebruikt als extensie.\n"}]}],"snapshots":[{"timestamp":1757003257602,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-nezhapro\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1757005364306,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nThe code below is a refactoring of:\r\n- the ElecFreaks 'pxt-nezha2' library:\r\n  https://github.com/elecfreaks/pxt-nezha2/blob/master/main.ts\r\nMIT-license.\r\n*/\r\n\r\nlet AnalogRJ = [AnalogPin.P8, AnalogPin.P1,\r\nAnalogPin.P12, AnalogPin.P2,\r\nAnalogPin.P14, AnalogPin.P13,\r\nAnalogPin.P16, AnalogPin.P15]\r\n\r\nlet DigitalRJ = [DigitalPin.P8, DigitalPin.P1,\r\nDigitalPin.P12, DigitalPin.P2,\r\nDigitalPin.P14, DigitalPin.P13,\r\nDigitalPin.P16, DigitalPin.P15]\r\n\r\nnamespace NezhaPro {\r\n\r\n    let i2cAddr: number = 0x10;\r\n    let servoSpeedGlobal = 900\r\n    let relativeAngularArr = [0, 0, 0, 0];\r\n\r\n    export enum MotorPostion {\r\n        //%block=\"M1\"\r\n        M1 = 1,\r\n        //%block=\"M2\"\r\n        M2 = 2,\r\n        //%block=\"M3\"\r\n        M3 = 3,\r\n        //%block=\"M4\"\r\n        M4 = 4\r\n    }\r\n\r\n    export enum MovementDirection {\r\n        //%block=\"clockwise\"\r\n        CW = 1,\r\n        //%block=\"counterclockwise\"\r\n        CCW = 2\r\n    }\r\n\r\n    export enum Mode {\r\n        //%block=\"degrees\"\r\n        Degree = 2,\r\n        //%block=\"turns\"\r\n        Circle = 1,\r\n        //%block=\"seconds\"\r\n        Second = 3\r\n    }\r\n\r\n    export function delayMs(ms: number): void {\r\n        let time = input.runningTime() + ms\r\n        while (time >= input.runningTime()) {\r\n\r\n        }\r\n    }\r\n\r\n    export function motorDelay(value: number, motorFunction: Mode) {\r\n        let delayTime = 0;\r\n        if (value == 0 || servoSpeedGlobal == 0) {\r\n            return;\r\n        } else if (motorFunction == Mode.Circle) {\r\n            delayTime = value * 360000.0 / servoSpeedGlobal + 500;\r\n        } else if (motorFunction == Mode.Second) {\r\n            delayTime = (value * 1000);\r\n        } else if (motorFunction == Mode.Degree) {\r\n            delayTime = value * 1000.0 / servoSpeedGlobal + 500;\r\n        }\r\n        basic.pause(delayTime);\r\n\r\n    }\r\n\r\n    function _move(motor: MotorPostion, direction: MovementDirection, value: number, mode: Mode): void {\r\n\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = direction;\r\n        buf[4] = 0x70;\r\n        buf[5] = (value >> 8) & 0XFF;\r\n        buf[6] = mode;\r\n        buf[7] = (value >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _stop(motor: MotorPostion): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5F;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _start(motor: MotorPostion, direction: MovementDirection, speed: number): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = direction;\r\n        buf[4] = 0x60;\r\n        buf[5] = Math.floor(speed);\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _angle(motor: MotorPostion): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x46;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 4);\r\n        return (arr[3] << 24) | (arr[2] << 16) | (arr[1] << 8) | (arr[0]);\r\n    }\r\n\r\n    export function _speed(motor: MotorPostion): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x47;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 2);\r\n        let retData = (arr[1] << 8) | (arr[0]);\r\n        return Math.floor(retData / 3.6) * 0.01;\r\n    }\r\n\r\n    export function _reset(motor: MotorPostion): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x1D;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        relativeAngularArr[motor - 1] = 0;\r\n        motorDelay(1, Mode.Second)\r\n    }\r\n\r\n    export function setServoSpeed(speed: number): void {\r\n        if (speed < 0) speed = 0;\r\n        speed *= 9;\r\n        servoSpeedGlobal = speed;\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x77;\r\n        buf[5] = (speed >> 8) & 0XFF;\r\n        buf[6] = 0x00;\r\n        buf[7] = (speed >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n\r\n    }\r\n\r\n    export function _version(): string {\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x88;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0x00;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        let version = pins.i2cReadBuffer(i2cAddr, 3);\r\n        return `V ${version[0]}.${version[1]}.${version[2]}`;\r\n    }\r\n\r\n}\r\n\r\nnamespace Nezha {\r\n\r\n    // MOTOR MODULE\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        speed = Math.map(speed, 0, 100, 0, 150)\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 150) speed = 150\r\n        else\r\n            if (speed < -150) speed = -150\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n        if (Servos[servo] != ServoType.ST180) return\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = speed;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // RJPort MODULE\r\n\r\n    export function analogPin(port: RJPort, line: RJLine): number {\r\n        return AnalogRJ[port * 2 + line]\r\n    }\r\n\r\n    export function digitalPin(port: RJPort, line: RJLine): number {\r\n        return DigitalRJ[port * 2 + line]\r\n    }\r\n\r\n    export function analogRead(port: RJPort, line: RJLine): number {\r\n        return pins.analogReadPin(AnalogRJ[port * 2 + line])\r\n    }\r\n\r\n    export function analogWrite(port: RJPort, line: RJLine, value: number) {\r\n        pins.analogWritePin(AnalogRJ[port * 2 + line], value)\r\n    }\r\n\r\n    export function digitalRead(port: RJPort, line: RJLine): Digital {\r\n        return pins.digitalReadPin(DigitalRJ[port * 2 + line])\r\n    }\r\n\r\n    export function digitalWrite(port: RJPort, line: RJLine, value: Digital) {\r\n        pins.digitalWritePin(DigitalRJ[port * 2 + line], value);\r\n    }\r\n}\r\n\r\n\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-nezhapro\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-ef-definitions\": \"github:CBurg-College/pxt-ef-definitions#b17496748ea808d089f8902356efe02e28f68569\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1757009901399,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nThe code below is a refactoring of:\r\n- the ElecFreaks 'pxt-nezha2' library:\r\n  https://github.com/elecfreaks/pxt-nezha2/blob/master/main.ts\r\nMIT-license.\r\n*/\r\n\r\nlet AnalogRJ = [AnalogPin.P8, AnalogPin.P1,\r\nAnalogPin.P12, AnalogPin.P2,\r\nAnalogPin.P14, AnalogPin.P13,\r\nAnalogPin.P16, AnalogPin.P15]\r\n\r\nlet DigitalRJ = [DigitalPin.P8, DigitalPin.P1,\r\nDigitalPin.P12, DigitalPin.P2,\r\nDigitalPin.P14, DigitalPin.P13,\r\nDigitalPin.P16, DigitalPin.P15]\r\n\r\nnamespace NezhaPro {\r\n\r\n    let i2cAddr: number = 0x10;\r\n    let servoSpeedGlobal = 900\r\n    let relativeAngularArr = [0, 0, 0, 0];\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export enum Mode {\r\n        //%block=\"turns\"\r\n        Circle = 1,\r\n        //%block=\"degrees\"\r\n        Degree = 2,\r\n        //%block=\"seconds\"\r\n        Second = 3\r\n    }\r\n\r\n    export function delayMs(ms: number): void {\r\n        let time = input.runningTime() + ms\r\n        while (time >= input.runningTime()) {\r\n\r\n        }\r\n    }\r\n\r\n    export function motorDelay(value: number, motorFunction: Mode) {\r\n        let delayTime = 0;\r\n        if (value == 0 || servoSpeedGlobal == 0) {\r\n            return;\r\n        } else if (motorFunction == Mode.Circle) {\r\n            delayTime = value * 360000.0 / servoSpeedGlobal + 500;\r\n        } else if (motorFunction == Mode.Second) {\r\n            delayTime = (value * 1000);\r\n        } else if (motorFunction == Mode.Degree) {\r\n            delayTime = value * 1000.0 / servoSpeedGlobal + 500;\r\n        }\r\n        basic.pause(delayTime);\r\n\r\n    }\r\n\r\n    function _move(motor: Motor, rotation: Spin, value: number, mode: Mode): void {\r\n\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = rotation + 1; // Spin.Clockwise = 1, Spin.AntiClockwise = 2\r\n        buf[4] = 0x70;\r\n        buf[5] = (value >> 8) & 0XFF;\r\n        buf[6] = mode;\r\n        buf[7] = (value >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _stop(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5F;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _start(motor: Motor, rotation: Spin, speed: number): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = rotation + 1; // Spin.Clockwise = 1, Spin.AntiClockwise = 2\r\n        buf[4] = 0x60;\r\n        buf[5] = Math.floor(speed);\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _angle(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x46;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 4);\r\n        return (arr[3] << 24) | (arr[2] << 16) | (arr[1] << 8) | (arr[0]);\r\n    }\r\n\r\n    export function _speed(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x47;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 2);\r\n        let retData = (arr[1] << 8) | (arr[0]);\r\n        return Math.floor(retData / 3.6) * 0.01;\r\n    }\r\n\r\n    export function _setServoSpeed(speed: number): void {\r\n        if (speed < 0) speed = 0;\r\n        speed *= 9;\r\n        servoSpeedGlobal = speed;\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x77;\r\n        buf[5] = (speed >> 8) & 0XFF;\r\n        buf[6] = 0x00;\r\n        buf[7] = (speed >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _reset(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1; // M1 = 1, ..., M4 = 4\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x1D;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        relativeAngularArr[motor - 1] = 0;\r\n        motorDelay(1, Mode.Second)\r\n    }\r\n\r\n    export function _version(): string {\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x88;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0x00;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        let version = pins.i2cReadBuffer(i2cAddr, 3);\r\n        return `V ${version[0]}.${version[1]}.${version[2]}`;\r\n    }\r\n\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        _start( motor, speed >= 0 ? Spin.Clockwise : Spin.AntiClockwise, speed)\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n}\r\n\r\nnamespace Nezha {\r\n\r\n    // MOTOR MODULE\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        speed = Math.map(speed, 0, 100, 0, 150)\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 150) speed = 150\r\n        else\r\n            if (speed < -150) speed = -150\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n        if (Servos[servo] != ServoType.ST180) return\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = speed;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // RJPort MODULE\r\n\r\n    export function analogPin(port: RJPort, line: RJLine): number {\r\n        return AnalogRJ[port * 2 + line]\r\n    }\r\n\r\n    export function digitalPin(port: RJPort, line: RJLine): number {\r\n        return DigitalRJ[port * 2 + line]\r\n    }\r\n\r\n    export function analogRead(port: RJPort, line: RJLine): number {\r\n        return pins.analogReadPin(AnalogRJ[port * 2 + line])\r\n    }\r\n\r\n    export function analogWrite(port: RJPort, line: RJLine, value: number) {\r\n        pins.analogWritePin(AnalogRJ[port * 2 + line], value)\r\n    }\r\n\r\n    export function digitalRead(port: RJPort, line: RJLine): Digital {\r\n        return pins.digitalReadPin(DigitalRJ[port * 2 + line])\r\n    }\r\n\r\n    export function digitalWrite(port: RJPort, line: RJLine, value: Digital) {\r\n        pins.digitalWritePin(DigitalRJ[port * 2 + line], value);\r\n    }\r\n}\r\n\r\n\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-nezhapro\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-ef-definitions\": \"github:CBurg-College/pxt-ef-definitions#b17496748ea808d089f8902356efe02e28f68569\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1757013029072,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nThe code below is a refactoring of:\r\n- the ElecFreaks 'pxt-nezha2' library:\r\n  https://github.com/elecfreaks/pxt-nezha2/blob/master/main.ts\r\nMIT-license.\r\n*/\r\n\r\nlet AnalogRJ = [AnalogPin.P8, AnalogPin.P1,\r\nAnalogPin.P12, AnalogPin.P2,\r\nAnalogPin.P14, AnalogPin.P13,\r\nAnalogPin.P16, AnalogPin.P15]\r\n\r\nlet DigitalRJ = [DigitalPin.P8, DigitalPin.P1,\r\nDigitalPin.P12, DigitalPin.P2,\r\nDigitalPin.P14, DigitalPin.P13,\r\nDigitalPin.P16, DigitalPin.P15]\r\n\r\nnamespace NezhaPro {\r\n\r\n    let i2cAddr: number = 0x10;\r\n    let servoSpeedGlobal = 900\r\n    let relAngleArr = [0, 0, 0, 0];\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export enum Mode {\r\n        //%block=\"turns\"\r\n        Circle = 1,\r\n        //%block=\"degrees\"\r\n        Degree = 2,\r\n        //%block=\"seconds\"\r\n        Second = 3\r\n    }\r\n\r\n    export enum DelayMode {\r\n        AutoDelayStatus = 1,\r\n        NoDelay = 0\r\n    }\r\n\r\n    export function delayMs(ms: number): void {\r\n        let time = input.runningTime() + ms\r\n        while (time >= input.runningTime()) { }\r\n    }\r\n\r\n    export function motorDelay(value: number, motorFunction: Mode) {\r\n        let delayTime = 0;\r\n        if (value == 0 || servoSpeedGlobal == 0) {\r\n            return;\r\n        } else if (motorFunction == Mode.Circle) {\r\n            delayTime = value * 360000.0 / servoSpeedGlobal + 500;\r\n        } else if (motorFunction == Mode.Second) {\r\n            delayTime = (value * 1000);\r\n        } else if (motorFunction == Mode.Degree) {\r\n            delayTime = value * 1000.0 / servoSpeedGlobal + 500;\r\n        }\r\n        basic.pause(delayTime);\r\n    }\r\n\r\n    function _move(motor: Motor, rotation: Spin, value: number, mode: Mode): void {\r\n\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = rotation + 1;\r\n        buf[4] = 0x70;\r\n        buf[5] = (value >> 8) & 0XFF;\r\n        buf[6] = mode;\r\n        buf[7] = (value >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _turnToAngle(motor: Motor, rotation: Spin, angle: number, isDelay: DelayMode = DelayMode.AutoDelayStatus): void {\r\n        while (angle < 0)\r\n            angle += 360\r\n        angle %= 360\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5D;\r\n        buf[5] = (angle >> 8) & 0XFF;\r\n        buf[6] = rotation + 1;\r\n        buf[7] = (angle >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4); // due to bug in ???\r\n        if (isDelay)\r\n            motorDelay(0.5, Mode.Second)\r\n    }\r\n\r\n    export function _stop(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5F;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _turnAtSpeed(motor: Motor, rotation: Spin, speed: number): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = rotation + 1;\r\n        buf[4] = 0x60;\r\n        buf[5] = Math.floor(speed);\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _readSpeed(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x47;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 2);\r\n        let retData = (arr[1] << 8) | (arr[0]);\r\n        return Math.floor(retData / 3.6) * 0.01;\r\n    }\r\n\r\n    export function _readAngle(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x46;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 4);\r\n        return (arr[3] << 24) | (arr[2] << 16) | (arr[1] << 8) | (arr[0]);\r\n    }\r\n\r\n    export function _absAngle(motor: Motor): number {\r\n        let position = _readAngle(motor)\r\n        while (position < 0) {\r\n            position += 3600;\r\n        }\r\n        return (position % 3600) * 0.1;\r\n    }\r\n\r\n    export function _setRelAngleNullPos(motor: Motor) {\r\n        relAngleArr[motor] = _readAngle(motor);\r\n    }\r\n\r\n    export function _relAngle(motor: Motor): number {\r\n        return (_readAngle(motor) - relAngleArr[motor]) * 0.1;\r\n    }\r\n\r\n    export function _setServoSpeed(speed: number): void {\r\n        if (speed < 0) speed = 0;\r\n        speed *= 9;\r\n        servoSpeedGlobal = speed;\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x77;\r\n        buf[5] = (speed >> 8) & 0XFF;\r\n        buf[6] = 0x00;\r\n        buf[7] = (speed >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _reset(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x1D;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        relAngleArr[motor - 1] = 0;\r\n        motorDelay(1, Mode.Second)\r\n    }\r\n\r\n    export function _version(): string {\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x88;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0x00;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        let version = pins.i2cReadBuffer(i2cAddr, 3);\r\n        return `V ${version[0]}.${version[1]}.${version[2]}`;\r\n    }\r\n\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        _turnAtSpeed( motor, speed >= 0 ? Spin.Clockwise : Spin.AntiClockwise, speed)\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n    }\r\n\r\n}\r\n\r\nnamespace Nezha {\r\n\r\n    // MOTOR MODULE\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        speed = Math.map(speed, 0, 100, 0, 150)\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 150) speed = 150\r\n        else\r\n            if (speed < -150) speed = -150\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n        if (Servos[servo] != ServoType.ST180) return\r\n        speed = Math.map(speed, -100, 100, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = speed;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    // RJPort MODULE\r\n\r\n    export function analogPin(port: RJPort, line: RJLine): number {\r\n        return AnalogRJ[port * 2 + line]\r\n    }\r\n\r\n    export function digitalPin(port: RJPort, line: RJLine): number {\r\n        return DigitalRJ[port * 2 + line]\r\n    }\r\n\r\n    export function analogRead(port: RJPort, line: RJLine): number {\r\n        return pins.analogReadPin(AnalogRJ[port * 2 + line])\r\n    }\r\n\r\n    export function analogWrite(port: RJPort, line: RJLine, value: number) {\r\n        pins.analogWritePin(AnalogRJ[port * 2 + line], value)\r\n    }\r\n\r\n    export function digitalRead(port: RJPort, line: RJLine): Digital {\r\n        return pins.digitalReadPin(DigitalRJ[port * 2 + line])\r\n    }\r\n\r\n    export function digitalWrite(port: RJPort, line: RJLine, value: Digital) {\r\n        pins.digitalWritePin(DigitalRJ[port * 2 + line], value);\r\n    }\r\n}\r\n\r\n\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-nezhapro\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-ef-definitions\": \"github:CBurg-College/pxt-ef-definitions#b17496748ea808d089f8902356efe02e28f68569\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1757014829262,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nThe code below is a refactoring of:\r\n- the ElecFreaks 'pxt-nezha2' library:\r\n  https://github.com/elecfreaks/pxt-nezha2/blob/master/main.ts\r\nMIT-license.\r\n*/\r\n\r\nlet AnalogRJ = [AnalogPin.P8, AnalogPin.P1,\r\nAnalogPin.P12, AnalogPin.P2,\r\nAnalogPin.P14, AnalogPin.P13,\r\nAnalogPin.P16, AnalogPin.P15]\r\n\r\nlet DigitalRJ = [DigitalPin.P8, DigitalPin.P1,\r\nDigitalPin.P12, DigitalPin.P2,\r\nDigitalPin.P14, DigitalPin.P13,\r\nDigitalPin.P16, DigitalPin.P15]\r\n\r\nnamespace NezhaPro {\r\n\r\n    let i2cAddr: number = 0x10;\r\n    let servoSpeedGlobal = 900\r\n    let relAngleArr = [0, 0, 0, 0];\r\n\r\n    let MFL = 0\r\n    let MFR = 1\r\n    let MRL = 2\r\n    let MRR = 3\r\n    let Motors = [Motor.M1, Motor.M2, Motor.M3, Motor.M4]\r\n    let Revert = [false, false, false, false]\r\n\r\n    export enum Mode {\r\n        //% block=\"revolutions\"\r\n        //% block.loc.nl=\"omwentelingen\"\r\n        Circle = 1,\r\n        //% block=\"degrees\"\r\n        //% block.loc.nl=\"graden\"\r\n        Degree = 2,\r\n        //% block=\"seconds\"\r\n        //% block.loc.nl\"seconden\"\"\r\n        Second = 3\r\n    }\r\n\r\n    export enum DelayMode {\r\n        AutoDelayStatus = 1,\r\n        NoDelay = 0\r\n    }\r\n\r\n    export function delayMs(ms: number): void {\r\n\r\n        let time = input.runningTime() + ms\r\n        while (time >= input.runningTime()) { }\r\n    }\r\n\r\n    export function motorDelay(value: number, motorFunction: Mode) {\r\n\r\n        let delayTime = 0;\r\n        if (value == 0 || servoSpeedGlobal == 0) {\r\n            return;\r\n        } else if (motorFunction == Mode.Circle) {\r\n            delayTime = value * 360000.0 / servoSpeedGlobal + 500;\r\n        } else if (motorFunction == Mode.Second) {\r\n            delayTime = (value * 1000);\r\n        } else if (motorFunction == Mode.Degree) {\r\n            delayTime = value * 1000.0 / servoSpeedGlobal + 500;\r\n        }\r\n        basic.pause(delayTime);\r\n    }\r\n\r\n    function _move(motor: Motor, rotation: Spin, value: number, mode: Mode): void {\r\n\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = rotation + 1;\r\n        buf[4] = 0x70;\r\n        buf[5] = (value >> 8) & 0XFF;\r\n        buf[6] = mode;\r\n        buf[7] = (value >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _turnToAngle(motor: Motor, rotation: Spin, angle: number, isDelay: DelayMode = DelayMode.AutoDelayStatus): void {\r\n\r\n        while (angle < 0)\r\n            angle += 360\r\n        angle %= 360\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5D;\r\n        buf[5] = (angle >> 8) & 0XFF;\r\n        buf[6] = rotation + 1;\r\n        buf[7] = (angle >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4); // due to bug in ???\r\n        if (isDelay)\r\n            motorDelay(0.5, Mode.Second)\r\n    }\r\n\r\n    export function _start(motor: Motor, rotation: Spin, speed: number): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = rotation + 1;\r\n        buf[4] = 0x60;\r\n        buf[5] = Math.floor(speed);\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _stop(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x5F;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _readSpeed(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x47;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 2);\r\n        let retData = (arr[1] << 8) | (arr[0]);\r\n        return Math.floor(retData / 3.6) * 0.01;\r\n    }\r\n\r\n    export function _readAngle(motor: Motor): number {\r\n        delayMs(4)\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x46;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        delayMs(4)\r\n        let arr = pins.i2cReadBuffer(i2cAddr, 4);\r\n        return (arr[3] << 24) | (arr[2] << 16) | (arr[1] << 8) | (arr[0]);\r\n    }\r\n\r\n    export function _absAngle(motor: Motor): number {\r\n        let position = _readAngle(motor)\r\n        while (position < 0) {\r\n            position += 3600;\r\n        }\r\n        return (position % 3600) * 0.1;\r\n    }\r\n\r\n    export function _setRelAngleNullPos(motor: Motor) {\r\n        relAngleArr[motor] = _readAngle(motor);\r\n    }\r\n\r\n    export function _relAngle(motor: Motor): number {\r\n        return (_readAngle(motor) - relAngleArr[motor]) * 0.1;\r\n    }\r\n\r\n    export function _setServoSpeed(speed: number): void {\r\n        if (speed < 0) speed = 0;\r\n        speed *= 9;\r\n        servoSpeedGlobal = speed;\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x77;\r\n        buf[5] = (speed >> 8) & 0XFF;\r\n        buf[6] = 0x00;\r\n        buf[7] = (speed >> 0) & 0XFF;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n    }\r\n\r\n    export function _reset(motor: Motor): void {\r\n        let buf = pins.createBuffer(8)\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = motor + 1;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x1D;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0xF5;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        relAngleArr[motor - 1] = 0;\r\n        motorDelay(1, Mode.Second)\r\n    }\r\n\r\n    export function _version(): string {\r\n        let buf = pins.createBuffer(8);\r\n        buf[0] = 0xFF;\r\n        buf[1] = 0xF9;\r\n        buf[2] = 0x00;\r\n        buf[3] = 0x00;\r\n        buf[4] = 0x88;\r\n        buf[5] = 0x00;\r\n        buf[6] = 0x00;\r\n        buf[7] = 0x00;\r\n        pins.i2cWriteBuffer(i2cAddr, buf);\r\n        let version = pins.i2cReadBuffer(i2cAddr, 3);\r\n        return `V ${version[0]}.${version[1]}.${version[2]}`;\r\n    }\r\n\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function setLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setFrontLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[0] = motor\r\n        Revert[0] = revert\r\n    }\r\n\r\n    export function setFrontRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[1] = motor\r\n        Revert[1] = revert\r\n    }\r\n\r\n    export function setRearLeftMotor(motor: Motor, revert: boolean) {\r\n        Motors[2] = motor\r\n        Revert[2] = revert\r\n    }\r\n\r\n    export function setRearRightMotor(motor: Motor, revert: boolean) {\r\n        Motors[3] = motor\r\n        Revert[3] = revert\r\n    }\r\n\r\n    // speed in %\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n        _start( motor, speed >= 0 ? Spin.Clockwise : Spin.AntiClockwise, speed)\r\n    }\r\n\r\n    // speed in %\r\n    export function fourWheelSpeed(frontleft: number, frontright: number, backleft: number, backright: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -frontleft : frontleft)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -frontright : frontright)\r\n        motorSpeed(Motors[MRL], Revert[MRL] ? -backleft : backleft)\r\n        motorSpeed(Motors[MRR], Revert[MRR] ? -backright : backright)\r\n    }\r\n\r\n    // speed in %\r\n    export function twoWheelSpeed(left: number, right: number) {\r\n        // supply positive values to obtain 'forward' spinning\r\n        motorSpeed(Motors[MFL], Revert[MFL] ? -left : left)\r\n        motorSpeed(Motors[MFR], Revert[MFR] ? -right : right)\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoPort(servo: Servo, ) {\r\n        switch (servo) {\r\n            Servo.S1:   \r\n        }\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(speed, 0, 100, 0, 150)\r\n        pins.servoWritePin(AnalogPin.P15, angle)\r\n    }\r\n\r\n    export function servoSpeed(servo: Servo, speed: number): void {\r\n    }\r\n\r\n\r\n    // RJPort MODULE\r\n\r\n    export function analogPin(port: RJPort, line: RJLine): number {\r\n        return AnalogRJ[port * 2 + line]\r\n    }\r\n\r\n    export function digitalPin(port: RJPort, line: RJLine): number {\r\n        return DigitalRJ[port * 2 + line]\r\n    }\r\n\r\n    export function analogRead(port: RJPort, line: RJLine): number {\r\n        return pins.analogReadPin(AnalogRJ[port * 2 + line])\r\n    }\r\n\r\n    export function analogWrite(port: RJPort, line: RJLine, value: number) {\r\n        pins.analogWritePin(AnalogRJ[port * 2 + line], value)\r\n    }\r\n\r\n    export function digitalRead(port: RJPort, line: RJLine): Digital {\r\n        return pins.digitalReadPin(DigitalRJ[port * 2 + line])\r\n    }\r\n\r\n    export function digitalWrite(port: RJPort, line: RJLine, value: Digital) {\r\n        pins.digitalWritePin(DigitalRJ[port * 2 + line], value);\r\n    }\r\n}\r\n\r\npins.servoSetPulse(AnalogPin.P15, 1500)\r\nbasic.forever(function () {\r\n    basic.showArrow(ArrowNames.North)\r\n    basic.pause(2000)\r\n    pins.servoWritePin(AnalogPin.P15, 0)\r\n    basic.showArrow(ArrowNames.South)\r\n    basic.pause(2000)\r\n})\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-nezhapro\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-ef-definitions\": \"github:CBurg-College/pxt-ef-definitions#b17496748ea808d089f8902356efe02e28f68569\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1757016053353}